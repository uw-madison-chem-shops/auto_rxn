{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"auto-rxn","text":"<p>Python package for running chemical reactions as defined by \"recipe\" files.</p>"},{"location":"#original-design","title":"original design","text":"<p>Credit for original design of this interface goes to Unni Kurumbail of the Herman's Group at University of Wisconsin-Madison Chemistry Department.</p> <p>https://github.com/ukurumbail/auto_rxn</p>"},{"location":"#enabling-technologies","title":"enabling technologies","text":"<p>Auto-rxn relies on a host of larger open-source software projects, highlighted here.</p> <p>Bluesky, a Python library for experimental orchestration.</p> <p>HAPPI, a database for access to hardware interfaces.</p> <p>yaq, a modular and extensible instrument control framework.</p> <p>The large scientific python ecosystem, especially NumPy, pandas, and Matplotlib. \u2764\ufe0f</p>"},{"location":"adding-devices/","title":"adding devices","text":"<p>Auto-rxn has been built to be as flexible as possible in accepting devices. Any device supporting Bluesky protocols should work, including a growing ecosystem of hardware interface packages.</p> <p>Auto-rxn relies on HAPPI for device-discovery. HAPPI provides a persistant database of what devices are avaliable on a given machine, and how to construct a Python interface to each device. When running from a recipe file, auto-rxn queries HAPPI for devices according to their <code>Control Point ID</code>. Sometimes it's useful to interact directly with HAPPI when managing devices for auto-rxn. Refer to the HAPPI documentation for more, or on the command line type.</p> <pre><code>$ happi --help\n</code></pre>"},{"location":"adding-devices/#initializing-happi-on-a-new-machine","title":"initializing HAPPI on a new machine","text":"<p>At minimum, HAPPI needs a configuration file and a database file to operate. You can quickly create these files in their default locations by typing the following into the command line.</p> <pre><code>$ happi config init\n</code></pre> <p>If your database is broken and you want to start fresh, you can do so using the following flag. Be careful, as this will delete your current database!</p> <pre><code>$ happi config init --overwrite\n</code></pre>"},{"location":"adding-devices/#populating-a-database-from-yaq","title":"populating a database from yaq","text":"<p>For yaq devices, there is a special integration between yaqd-control and HAPPI that makes populating the HAPPI database simple.</p> <pre><code>$ yaqd list --format happi | happi update -\n</code></pre> <p>You can safely repeat this command whenever you add or change a yaq daemon.</p>"},{"location":"adding-devices/#interacting-with-the-happi-database","title":"interacting with the HAPPI database","text":"<p>Auto-rxn users will find it useful to know a few basic ways of interacting with the HAPPI database.</p> <p>To list all entries in the HAPPI databse:</p> <pre><code>$ happi search \"*\"\n</code></pre> <p>To drop into an iPython shell with all devices loaded:</p> <pre><code>$ happi load \"$(happi search \"*\" --names)\"\n</code></pre>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#conda-forge-recommended","title":"conda-forge (recommended)","text":"<p>The conda package manager is recommended for scientists wanting access to Python tools. If you're just getting started with Python, we recommend miniconda.</p> <p>https://docs.conda.io/en/latest/miniconda.html</p> <p>Once conda is installed on your machine, you can install auto-rxn. On a Windows machine, use Anaconda Prompt for these commands.</p> <pre><code>$ conda config --add channels conda-forge\n$ conda install auto_rxn\n</code></pre> <p>If you installed a previous version of auto-rxn using conda, you can update using the following command.</p> <pre><code>$ conda update auto_rxn\n</code></pre>"},{"location":"installation/#pypi","title":"PyPI","text":"<p>Auto-rxn is also avaliable from Python's default package manager, pip.</p> <pre><code>$ python -m pip install auto_rxn\n</code></pre> <p>If you installed a previous version of auto-rxn from PyPI, you can update using the following command.</p> <pre><code>$ python -m pip install -U auto_rxn\n</code></pre>"},{"location":"limits/","title":"limits","text":"<p>Auto-rxn enforces limits on all control points for the duration of a reaction. These limits exist to help enforce safety conditions during unattended reactions. Like any software-based saftey feature, auto-rxn limits should be paired with hardware safety features such as runaway heater shutoff controllers.</p> <p>If the limits are exceeded during a reaction, auto-rxn will set all devices to fallback positions and stop the reaction.</p> <p>To set limits:</p> <pre><code>$ auto-rxn edit-limits\n</code></pre> <p>To view current limits:</p> <pre><code>$ auto-rxn list-devices\n</code></pre> <p>A copy of the limits as they were at the start of each reaction are stored in the <code>auto-rxn-data</code> directory. It's important to note that this backup occurs immediately before the recipe runs since fallback positions can change over the course of a reaction.</p> <p>Limits can always be numerical, including <code>+inf</code>, <code>-inf</code>, and (in some cases) <code>nan</code>. Limits can sometimes be strings, for devices that accept string arguments to set (in a yaq context, daemons following is-discrete trait).</p>"},{"location":"limits/#fallback","title":"fallback","text":"<p>The setting for fallback is probably the most important for a given control point. If any limit is exceeded for any control point, each control point will be set to its fallback position A fallback of <code>nan</code> tells auto-rxn to leave that control point where it is during a fault.</p> <p>Fallback can be set directly using <code>$ auto-rxn edit-limits</code>, or set during a recipe by appending <code>fallback_position</code> to the control point ID. For example, if your control point is furnace you could set the ID <code>furnace.fallback_position</code>. Auto-rxn supports this feature because sometimes the ideal fallback positions are dependent on the step within the recipe.</p>"},{"location":"limits/#lower-and-upper","title":"lower and upper","text":"<p>These are basic upper and lower limits. Auto-rxn considers it a fault if these limits are exceeded by the set value or the proccess value.</p>"},{"location":"limits/#atol","title":"atol","text":"<p>Absolute tolerance. Considered a fault if the difference between the PV and the SV has greater magnitude than atol setting.</p>"},{"location":"limits/#rtol","title":"rtol","text":"<p>Relative tolerance. Considered a fault if the difference between the PV and the SV has greater magnitude than rtol as a percentage of the SV. Rtol can be useful if you want to allow a wider toleraence margin at higher set values and a tighter and lower set values.</p> <p>If your device will be set to zero during the reaction, you have to set deadband if you're using rtol. The ratio of difference to SV is a divide by zero error if SV equals zero.</p>"},{"location":"limits/#deadband","title":"deadband","text":"<p>Allows for ignoring limit checks when both PV and SV are near zero. If both PV and SV are within deadband of zero, all other checks are ignored.</p>"},{"location":"limits/#delay","title":"delay","text":"<p>Setting to allow limit overrides for a period of time. If nonzero, limit checks must fail consistently several times before auto-rxn considers the device to be in fault. Units of seconds. Set delay to zero to trigger fault immediately when out of bounds.</p>"},{"location":"recipes/","title":"recipes","text":"<p>CSV file. Here's a simple example including some discrete hardware.</p> Control Point ID mymotor myfurnace discrete discrete.fallback_position RECIPE_STARTS_BELOW 0.1 10 100 red blue 0.1 20 200 yellow blue 0.2 30 300 orange red 0 10 100 green red"}]}